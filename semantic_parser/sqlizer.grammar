# SQLizer Semantic Parser v1.0
# 
#    Simple Rigid Grammar
# 
# Usage: 
#   Run on the simple grammar (with all four tags on - [compositional join bridge inject])
#   ./run @mode=simple -Grammar.inPaths sqlizer/grammars/lab.grammar -languageAnalyzer corenlp.CoreNLPAnalyzer -Grammar.tags compositional join bridge inject
# 
#   Run on the simple grammar (with two tags on - [compositional join])
#   ./run @mode=simple -Grammar.inPaths sqlizer/simple.grammar -languageAnalyzer corenlp.CoreNLPAnalyzer -Grammar.tags compositional join
# 
#   Run the training too
#   ./run @mode=simple -Grammar.inPaths sqlizer/grammars/lab.grammar -languageAnalyzer corenlp.CoreNLPAnalyzer -Dataset.inPaths train:sqlizer/grammars/train -FeatureExtractor.featureDomains rule

(rule $Noun ($LEMMA_TOKEN) (FilterPosTagFn token WRB WP NN NNS NNP NNPS))
(rule $SimpleNounPhrase ($Noun) (ConcatFn " "))
(rule $SimpleNounPhrase ($Noun $SimpleNounPhrase) (ConcatFn " "))


# Name Entities: Match an entity if it is a sequence of NE tags or NNP tags or of minimal length
(rule $NamedEntity ($PHRASE) (FilterNerSpanFn PERSON ORGANIZATION LOCATION MISC))
(rule $NamedEntity ($PHRASE) (FilterPosTagFn span NNP))

(rule $TokenSpan ($PHRASE) (FilterSpanLengthFn 1))
(rule $TokenSpan ($LEMMA_TOKEN) (FilterSpanLengthFn 1))

# Lexicon
# TODO: Make the lexicon entities realize their type
(rule $Entity ($NamedEntity) (IdentityFn))
(rule $Entity ($TokenSpan) (IdentityFn))
(rule $Entity ($PHRASE) (DateFn)) # Example: 2002

# Define wh-words
(rule $AggHint (how many) (ConstantFn null null))
(rule $AggHint (how much) (ConstantFn null null))
(rule $AggHint (number of) (ConstantFn null null))
(rule $GroupHint (for each) (ConstantFn null null))
(rule $GroupHint (for every) (ConstantFn null null))

# (rule $GroupOp ($GroupHint) (ConstantFn (lambda x 
#     ( call + (call + (string "agg:groupby(") (var x) ) (string ")") )
# )))

(rule $GroupOp ($GroupHint) (ConstantFn (lambda x 
    (call +  (string "agg:groupby(") (var x)  (string ")") )
)))

(rule $Operator ($AggHint) (ConstantFn (lambda x 
    (call +  (string "agg:count(") (var x)  (string ")") )
)))

# High Level Entity
(rule $Group (($GroupOp) ($SimpleNounPhrase)) (JoinFn forward betaReduce))
(rule $Aggregate ($Operator $SimpleNounPhrase) (JoinFn forward betaReduce))

# ---------         Root rules              ------------
# (rule $ROOT (($Whword optional) ($Padding optional) $Operator ($Padding optional) $Entities) (JoinFn forward betaReduce))

(rule $Padding ($PHRASE) (IdentityFn)) # Can skip these sequences
(rule $Set ($Aggregate) (IdentityFn))
(rule $Set ($Group) (IdentityFn))
(rule $ROOT ($Set) (IdentityFn))
(rule $ROOT ($Set $Set) (ConcatFn ", "))

